name: Code-300-Server
on:
  push:
  workflow_dispatch:

permissions:
  contents: read
  checks: write
  id-token: write

env:
  TF_VERSION: "1.12.2"
  AWS_REGION: {{region}}

jobs:
  server-operations:
    runs-on: ubuntu-latest
    steps:
      - name: Version of AWS CLI
        run: |
          echo "AWS CLI version:"
          which aws
          aws --version

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment

      - name: Configure AWS credentials
        uses: ./.github/actions/aws-credentials
        with:
          account-id: {{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}
          role-name: {{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-ops-deploy-ec2-role

      - name: Display Environment Info
        run: |
          echo "Event name: {{{githubVarsOpen}}} github.event_name  {{{githubVarsClose}}}"
          echo "Branch: {{{githubVarsOpen}}} env.BRANCH  {{{githubVarsClose}}}"
          echo "Environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"

      - name: Get Terraform Outputs
        uses: ./.github/actions/terraform-outputs
        with:
          terraform-dir: {{opsModule.moduleId}}/terraform
          environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}
          project-name: {{projectName}}

      - name: Set Deployment Environment Variables  
        run: |
          echo "üîß Setting up deployment environment variables..."
          
          # Set SPRING_PROFILE based on ENVIRONMENT
          echo "SPRING_PROFILE={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" >> $GITHUB_ENV
          echo "‚úÖ SPRING_PROFILE set to: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          
          echo "üìã Environment Variables Set:"
          echo "  SPRING_PROFILE: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          echo "  OPS_BUCKET: ${OPS_BUCKET}"

      - name: Discover EC2 Instances
        uses: ./.github/actions/ec2-discovery
        with:
          project-name: {{projectName}}
          environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}

      - name: Deploy - Add build info
        run: |
          mkdir -p {{backendModule.moduleId}}/src/main/resources
          echo -e "gh.build={{{githubVarsOpen}}} github.run_number  {{{githubVarsClose}}}\\ngh.attempt={{{githubVarsOpen}}} github.run_attempt  {{{githubVarsClose}}}\\ngh.action={{{githubVarsOpen}}} github.action  {{{githubVarsClose}}}\\ngh.modifiedDate={{{githubVarsOpen}}} github.event.repository.updated_at  {{{githubVarsClose}}}\\ngh.sha=$( git rev-parse --short HEAD )" > {{backendModule.moduleId}}/src/main/resources/version.properties

      - name: Deploy - Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'adopt'
          java-version: '21'

      - name: Deploy - Setup Gradle
        uses: gradle/gradle-build-action@v2
        with:
          gradle-version: current
    
      - name: Deploy - Build Application (with tests)
        run: |
          cd {{backendModule.moduleId}}
          gradle -PversionArg=1.0.{{{githubVarsOpen}}} github.run_number  {{{githubVarsClose}}}.{{{githubVarsOpen}}} github.run_attempt  {{{githubVarsClose}}} bootJar -x test

      - name: Deploy - Sync JAR to S3
        run: |
          JAR_NAME="{{backendModule.name}}-api-1.0.{{{githubVarsOpen}}} github.run_number  {{{githubVarsClose}}}.{{{githubVarsOpen}}} github.run_attempt  {{{githubVarsClose}}}.jar"
          echo "üì¶ Syncing JAR to S3 ops bucket: ${OPS_BUCKET}/jars/"
          echo "JAR: ${JAR_NAME}"
          
          # Verify JAR file exists
          if [ ! -f "{{backendModule.moduleId}}/build/libs/${JAR_NAME}" ]; then
            echo "‚ùå JAR file not found: {{backendModule.moduleId}}/build/libs/${JAR_NAME}"
            echo "üìÅ Available files in {{backendModule.moduleId}}/build/libs/:"
            ls -la {{backendModule.moduleId}}/build/libs/ || echo "Directory not found"
            exit 1
          fi
          
          # Show JAR file info
          echo "üìã JAR file details:"
          ls -lh "{{backendModule.moduleId}}/build/libs/${JAR_NAME}"
          
          # Create a staging directory for sync
          mkdir -p ./staging/jars
          cp {{backendModule.moduleId}}/build/libs/${JAR_NAME} "./staging/jars/"
          
          # Sync the staging/jars directory to S3
          echo "üöÄ Syncing JAR to S3..."
          if aws s3 sync ./staging/jars/ "s3://${OPS_BUCKET}/modules/{{backendModule.moduleId}}/jars/" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}; then
            echo "‚úÖ Successfully synced JAR to S3 ops bucket"
            echo "JAR_NAME=${JAR_NAME}" >> $GITHUB_ENV
            
            # Verify what was uploaded
            echo "üîç Verifying uploaded JAR:"
            aws s3 ls "s3://${OPS_BUCKET}/modules/{{backendModule.moduleId}}/jars/${JAR_NAME}" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}
            
            # Clean up staging directory
            rm -rf ./staging
          else
            echo "‚ùå Failed to sync JAR to S3 ops bucket: ${OPS_BUCKET}"
            rm -rf ./staging
            exit 1
          fi

      - name: Deploy - Sync EC2 Setup Scripts to S3
        run: |
          echo "üìã Syncing latest EC2 setup scripts from Git to S3..."
          echo "Source: ./{{backendModule.moduleId}}/ec2-setup/"
          echo "Target: s3://${OPS_BUCKET}/modules/{{backendModule.moduleId}}/ec2-setup/"

          # Verify source directory exists
          if [ ! -d "./{{backendModule.moduleId}}/ec2-setup" ]; then
            echo "‚ùå Source directory ./{{backendModule.moduleId}}/ec2-setup not found"
            exit 1
          fi

          # Copy zz_grablin.json to ec2-setup directory as genesis3.json for deployment
          if [ -f "./zz_grablin.json" ]; then
            echo "üìã Copying zz_grablin.json to ec2-setup/genesis3.json..."
            cp ./zz_grablin.json ./{{backendModule.moduleId}}/ec2-setup/genesis3.json
            echo "‚úÖ genesis3.json created from zz_grablin.json"
          else
            echo "‚ö†Ô∏è zz_grablin.json not found in project root"
          fi

          # Show what we're about to sync
          echo "üìÅ Files to sync:"
          ls -la ./{{backendModule.moduleId}}/ec2-setup/

          # Sync EC2 setup scripts to S3 with delete flag to remove old files
          if aws s3 sync ./{{backendModule.moduleId}}/ec2-setup/ "s3://${OPS_BUCKET}/modules/{{backendModule.moduleId}}/ec2-setup/" --delete --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}; then
            echo "‚úÖ Successfully synced EC2 setup scripts to S3"

            # Verify what was uploaded
            echo "üîç Verifying uploaded files:"
            aws s3 ls "s3://${OPS_BUCKET}/modules/{{backendModule.moduleId}}/ec2-setup/" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}
          else
            echo "‚ùå Failed to sync EC2 setup scripts to S3"
            exit 1
          fi

      - name: Deploy - Copy EC2 Setup Scripts and Initialize
        run: |
          echo "üîß Preparing EC2 instances with setup scripts..."
          
          # Convert comma-separated instances to space-separated for AWS CLI
          INSTANCE_LIST=$(echo "${EC2_INSTANCES}" | tr ',' ' ')
          echo "Target instances: ${INSTANCE_LIST}"
          
          # Copy ec2-setup scripts from S3 and run init.sh
          echo "üìã Copying EC2 setup scripts and initializing instances..."
          INIT_COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${INSTANCE_LIST} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"=== Syncing EC2 setup scripts from S3 ===\"",
              "sudo mkdir -p /opt/{{backendModule.name}}/ec2-setup",
              "aws s3 sync s3://'${OPS_BUCKET}'/modules/{{backendModule.moduleId}}/ec2-setup/ /opt/{{backendModule.name}}/ec2-setup/ --region '${AWS_REGION}'",
              "sudo chmod +x /opt/{{backendModule.name}}/ec2-setup/*.sh",
              "echo \"=== Running initialization script ===\"",
              "sudo /opt/{{backendModule.name}}/ec2-setup/init.sh '${JAR_NAME}' '${SPRING_PROFILE}'"
            ]' \
            --timeout-seconds 1800 \
            --query 'Command.CommandId' \
            --output text)
          
          echo "EC2 Setup Command ID: ${INIT_COMMAND_ID}"
          
          echo "‚è≥ Waiting for EC2 setup and initialization to complete..."
          
          # Convert instances to array for status checking
          IFS=' ' read -ra INSTANCE_ARRAY <<< "${INSTANCE_LIST}"
          
          # Wait for command completion on all instances
          for i in {1..120}; do
            ALL_COMPLETE=true
            ALL_SUCCESS=true
            
            echo "=== Checking initialization status (attempt ${i}/120) ==="
            
            for INSTANCE in "${INSTANCE_ARRAY[@]}"; do
              # Trim whitespace
              INSTANCE=$(echo "${INSTANCE}" | xargs)
              
              STATUS=$(aws ssm get-command-invocation \
                --command-id "${INIT_COMMAND_ID}" \
                --instance-id "${INSTANCE}" \
                --query 'Status' \
                --output text 2>/dev/null || echo "InProgress")
              
              echo "üìä Instance ${INSTANCE}: ${STATUS}"
              
              if [ "${STATUS}" = "Failed" ]; then
                echo "‚ùå Initialization failed on instance ${INSTANCE}"
                echo "=== Error Output for ${INSTANCE} ==="
                aws ssm get-command-invocation \
                  --command-id "${INIT_COMMAND_ID}" \
                  --instance-id "${INSTANCE}" \
                  --query 'StandardErrorContent' \
                  --output text
                echo "=== Standard Output for ${INSTANCE} ==="
                aws ssm get-command-invocation \
                  --command-id "${INIT_COMMAND_ID}" \
                  --instance-id "${INSTANCE}" \
                  --query 'StandardOutputContent' \
                  --output text
                exit 1
              elif [ "${STATUS}" != "Success" ]; then
                ALL_SUCCESS=false
                # Both "Pending" and "InProgress" mean the command hasn't finished yet
                if [ "${STATUS}" = "InProgress" ] || [ "${STATUS}" = "Pending" ]; then
                  ALL_COMPLETE=false
                fi
              fi
            done

            if [ "${ALL_SUCCESS}" = "true" ]; then
              echo "‚úÖ Initialization completed successfully on all instances"
              
              # Show successful output from all instances
              echo "üîç Initialization results:"
              for INSTANCE in "${INSTANCE_ARRAY[@]}"; do
                INSTANCE=$(echo "${INSTANCE}" | xargs)
                echo "üìã Instance ${INSTANCE} initialization output (last 20 lines):"
                aws ssm get-command-invocation \
                  --command-id "${INIT_COMMAND_ID}" \
                  --instance-id "${INSTANCE}" \
                  --query 'StandardOutputContent' \
                  --output text | tail -n 20
                echo
              done
              break
            fi
            
            if [ "${ALL_COMPLETE}" = "true" ]; then
              echo "‚ùå Some instances completed but not all succeeded"
              exit 1
            fi
            
            sleep 15
          done
          
          # If we reach here without success, it timed out
          if [ "${ALL_SUCCESS}" != "true" ]; then
            echo "‚ùå Initialization timed out after 30 minutes"
            # Show any available output even on timeout
            for INSTANCE in "${INSTANCE_ARRAY[@]}"; do
              INSTANCE=$(echo "${INSTANCE}" | xargs)
              echo "--- Instance ${INSTANCE} Output ---"
              aws ssm get-command-invocation \
                --command-id "${INIT_COMMAND_ID}" \
                --instance-id "${INSTANCE}" \
                --query 'StandardOutputContent' \
                --output text || true
              echo "--- Instance ${INSTANCE} Errors ---"
              aws ssm get-command-invocation \
                --command-id "${INIT_COMMAND_ID}" \
                --instance-id "${INSTANCE}" \
                --query 'StandardErrorContent' \
                --output text || true
              echo
            done
            exit 1
          fi
          echo "‚úÖ EC2 setup and initialization completed"
          echo "üéâ Deployment to {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}} environment completed successfully!"
          echo "üìã Summary:"
          echo "  - JAR: ${JAR_NAME}"
          echo "  - Environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          echo "  - Spring Profile: ${SPRING_PROFILE}"
          echo "  - Instances: ${EC2_INSTANCES}"
          echo "  - Service: {{backendModule.name}}-api.service"

      - name: Enable ALB Health Checks
        run: |
          echo "üîç Checking if ALB health checks are already enabled..."
          
          # Check current health check type
          CURRENT_HEALTH_CHECK=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-asg" \
            --query 'AutoScalingGroups[0].HealthCheckType' \
            --output text 2>/dev/null || echo "NONE")
          
          echo "Current health check type: ${CURRENT_HEALTH_CHECK}"
          
          if [ "${CURRENT_HEALTH_CHECK}" = "ELB" ]; then
            echo "‚úÖ ALB health checks are already enabled"
            echo "üîç Current ASG health check configuration:"
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-asg" \
              --query 'AutoScalingGroups[0].{HealthCheckType:HealthCheckType,HealthCheckGracePeriod:HealthCheckGracePeriod}' \
              --output table
          else
            echo "üîÑ Enabling ALB health checks for Auto Scaling Group..."
            
            # Run the enable health checks script
            cd {{opsModule.moduleId}}/helper
            chmod +x enable-health-checks.sh
            ./enable-health-checks.sh {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}
            
            echo "‚úÖ ALB health checks enabled successfully!"
          fi